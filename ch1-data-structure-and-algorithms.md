

# 1-1. 자료구조

사람들이 사물 편리하고 효율적으로 사용할려고 정리하는 것처럼 컴퓨터에서도 데이터(자료)들을정리하고 조직화하는 여러가지 구조들이 있다. 
이를 자료 구조라고함

```
- 단순자료구조 
| - 정수,실수, 문자
- 복합자료구조(컨테이너 같은)
| - 선형자료구조
| | - 배열구조(리스트, 스택, 큐, 덱)
| | - 연결구조(리스트, 스택, 큐, 덱)
| - 비선형자료구조 
| | - 트리(일반트리, 이진트리-힙,탐색-)
| | - 그래프(가중치 그래프)
```



# 1-2. 알고리즘 

- 프로그램 = 자료구조 + 알고리즘

대부분의 프로그램들은 데이터를 차리하고 사용자에게 결과물을 제공한다. 이때 데이터를 자료구조로 관리하고 이 데이터를 효율적으로 처리하기 위한 과정을 알고리즘이라고 한다. 요컨대 어떤 문제를 해결하는 절차를 알고리즘 이라고 하면 됨 

- 더 좋은 알고리즘을 사용하려면 대부분 더 복잡한 자료구조 사용해야함
- 알고리즘에서 각 명령어는 모호하지 않고 명백해야하고, 수행 후 반드시 종료되어야한다
- 보통 자연어, 유사코드(수도코드), 흐름도(~~직접작성해보면 꽤 피곤했다~~), 코드로 구현

# 1-3. 추상자료형(Abstrqct Data Type)

프로그래머가 추상적으로 정리한 자료형. 추상자료형은 어떤 자료들과 자료에 가해지는 연산들을 구체적으로 표시한다.

추상 = 어떤자료나 연산이 제공되는가만 정의하고 어떻게는 정의하지 않음. 사용자는 세부사항을 볼 필요 없기 때문에 보통 프롤그램 구현에 대한 세부 사항은 감춘 간단한 인터페이스로 제공됨

추상 자료형은 보통 클래스로 구현됨

```

class Bag:
	
	def __init__(self):
		self.bag = []

	def contains(self,e):
		# bag에 e가 있는지 검사하는 함수 
		return e in self.bag

	def insert(self, e):
		# bag에 e를 넣는함수
		self.bag.append(e)

```




# 1-4. 알고리즘 성능분석

- 속도 빠르면서 메모리 적게 사용하는 알고리즘이 좋긴한데 보통 성능 말 할 때 실행시간이 중요해서 실행시간이 알고리즘 효율성 평가기준

- 알고리즘 직접 구현하지 않고 효율성을 따질려면 복잡도 분석(complexity analysis)으로 가능 -> 입력 개수 n이 증가할 때 실행시간이 어떤 형태로 증가하는지 분석만함

- 같은 알고리즘이라도 입력종류에 따라 다른 실행시간 보일 수 있다. 정류장까지 걸어가서 버스타고 학교가는걸 생각해보자. 알고리즘은 동일하지만 버스가 언제 도착하느냐에 따라 등교시간이 달라질수 있다(best case, average case, worst case)

- 알고리즘에서 최대한 불리하 ㄴ입력 데이터 사용하는 worst case 실행 시간이 제일 중요 


## a. 시간복잡도

예를들어, 
`가방에 새 물건 넣을때 1. 맨위에 있는 물건 위에 쌓는다 2. 맨 아래에 넣기 위해 모든 물건 빼고 다시 넣는다`. 라고 하자. 

 이때 가방에 넣는 물건을 100개로 늘렸을 때 1번 방법이 2번보다 더 빠르게 작업을 끝낸다. 이때 실행 시간이 아니라 `연산 횟수`를 분석한다. 이때 연산수를 n의 함수로 나타낸게 `시간 복잡도 함수`다.

 ```
 시간복잡도 함수 = T(n)
 ```

ex) n^2 구하는 알고리즘 복잡도

|알고리즘|A|B|
|---|---|---|
|수도코드|sum <- n*n | for i=1; i<n i++; sum- sum+n|
|연산횟수|대입연산1, 곱셈연산1|대입연산n+1, 덧셈연산:n|
|복잡도함수T(n)|2|2n+1|

알고리즘 A가 더 효율적

## b. 빅오 표기법

시간복잡도 함수는 n이 커질수록 차수가 가장 큰 항의 영향이 절대적이 된다.
따라서 함수 전체항이 아니라 최고차항만 고려하면 된다

|시간복잡도함수|BigO표기|
|---|---|
|T(n)=2|O(1)|
|T(n)=2n+1|O(n)|
|T(n)=2n^2+n+1|O(n^2)|


- O(1)은 입력이 아무리 많아도 항상 일정한 시간에 처리 된다
- O(n)은 입력과 연산 횟수가 비례함
- 이러다보니 시간복잡도함수는 빅오 표가법의 상한을 나타낸다

## c. 빅오메가와 빅세타표기법

- 빅오메가 : 하한을 고려 
- 빅세타  : 빅오, 빅오메가, 빅세타 중 가장 정밀하지만 통상적으로 빅오 표기법 사용

# 1-5 시간복잡도 분석; 순환 알고리즘 recursion 


## 순환 알고리즘

- 재귀함수 = 순환 recursion, 자기 자신을 호출해 문제 해결하는 기법
- 애초에 순환 문제나 그러한 자료구조 다루는 프로그램에 적합(ex: 팩토리얼)

```
n!  순환적이다!!
= 1 (if n ==1 )
=  n*(n-1)! (if n>1)




##### 순환구조
# 자기 자신 호출하는 부분과 호출 멈추는 부분으로 이루어짐
def factorial(n):
	if n == 1:
		return 1
	else: 
		return n*factorial(n-1)


##### 반복구조
def factorial(n):
	result = 1
	for i in range(1, n+1):
		result = result*i
	return result

```

- 이때 순환구조나 반복구조 모두 O(n)으로 입력값에 따라 연산횟수가 비례함 그런데 `함수 호출 부담에 의해 반복되다보니 순환구조가 느리다` 순환구조는 이해하기 쉬울지 몰라도 수행시간과 기억공간 사용에 있어 비효율적 


## 순환이 더 빠를 때 ?

- 거듭제곱 구하기 예제(x^n구하는 함수 )

```
def power(x,n): 
	res = 1
	for i in range(1,n+1);
		res = res * x
	return res
```

그런데 더 효율적인 방법 -> 만약에 n이 짝수 일 때와 홀수 일 때를 구분한다면?

- n이 짝수 일 때 
- n이 홀수 일 때 

```
```




## 근데 순환이 느릴 때가 더 많다 (피보나치수열)

- 순환구조 사용
- 반복구조 사용

## 하노이의 탑
